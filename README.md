# 윤병현 React2-3-1

<br>

## 3주차 정리 (23.09.14)
## 가.  SWC와 Babel 비교

1. Babel 단점
- Babel로 변환된 코드를 이해하기 어렵다.
- 원 코드에 비해 변환 코드의 길이가 늘어난다.
- 변환에 시간이 많이 걸린다.

1. SWC의 장점
- Next 12 이후 별도의 설정 없이 SWC를 사용할 수 있다. Next.js에 내장되어 있다.
- Rust의 WASM(WebAssembly) 지원으로 어떤 종류의 플랫폼에서도 Next.js 개발을 할 수 있다
- 변환 시간이 빠르다
- 커뮤니티가 빠르게 성장하고 있어 도움 받기가 쉽다.

## 나.  서버 사이드 렌더딩(SSR)

- 생소할 수도 있지만 웹 페이지를 제공하는 가장 흔한 방법입니다.
- APM을 이용하는 일반적인 웹 페이지 생성이라고 보면 됩니다.
- 여기에 자바스크립트 코드가 적제되면 동적으로 페이지 내용을 렌더링합니다.

- Next.js도 이와 같이 동적으로 페이지를 렌더링할 수 있습니다.
- 그리고 여기에 스크립트 코드를 집어 넣어서 나중에 웹 페이지를 동적으로 처리할 수도 있는데 이를 하이드레이션이라고 합니다.

- 예를 들면 어떤 사람이 작성한 블로그 글을 한 페이지에 모아서 작성해야 한다면 SSR을 이용하는 것이 적당합니다.
- 서버 사이드 렌더링 → 자바스크립트가 하이드레이션된 페이지를 전송 → 클라이언트에서 DOM 위에 각 스크립트 코드를 하이드레이션

## 다.  렌더링 전략

- 렌더링 전략이란 웹 페이지 또는 웹 애플리케이션을 웹 브라우저에 제공하는 방법을 의미합니다.
- 정적인 페이지 제작에는 Gatsby를 추천합니다

- Next.js에서는 이 모든 방법을 완전히 새로운 수준으로 제공합니다.
- 어떤 페이지는 빌드 시점에 정적으로 생성하고, 어떤 페이지는 실행 시점에 동적으로 생성할지 쉽게 정할 수 있습니다.
- 또한 특정 페이지에 대한 요청이 있을 때마다 페이지를 다시 생성할 수도 있습니다.
- 그리고 반드시 클라이언트에서 렌더링해야 할 컴포넌트도 지정할 수 있어 개발이 쉽습니다.

- 리엑트 하이드레이션 덕분에 이 상태에서 웹 앱은 싱글 페이지 애플리케이션(SPA) 처럼 작동할 수 있습니다
- CSR과 SSR의 장점을 모두 가지는 것입니다.
- 특정 렌더링 전략만 사용한다고 가정하면 SSR이 CSR에 비해 여러 가지 장점이 있습니다.

### SSR의 장점

- 더 안전한 웹 애플리케이션: 쿠키 관리, 주요 API,데이터 검증 등과 같은 작업을 서버에서 처리하 기 때문에 중요한 데이터를 클라이언트에 노출할 필요가 없기 때문입니다.
- 더 뛰어난 웹 사이트 호환성: 클라이언트 환경이 자바스크립트를 사용하지 못하거나 오래된 브라우저를 사용하더라도 서비스를 제공할 수 있습니다.
- 더 뛰어난 SEO: 서버가 렌더링한 HTML을 받기 때문에 봇이나 웹 크롤러가 페이지를 렌더링할 필 요가 없기 때문입니다.

### SSR이 최적의 렌더링 전략이 아닌 경우

- 클라이언트가 페이지를 요청할 때마다 페이지를 다시 렌더링할 수 있는 서버가 필요합니다.
- 다른 방식에 비해 SSR이 더 많은 자원을 소모하고, 더 많은 부하를 보이며 유지 보수 비용도 증가 합니다.
- 페이지에 대한 요청을 처리하는 시간이 길어집니다.
- 페이지가 외부 API 또는 데이터 소스에 접근해야 한다면, 해당 페이지를 렌더링할 때마다 이를 다시 요청해야 합니다.
- 페이지 간의 이동은 CSR에 비해 느립니다.

- 중요한 것은 Next.js가 기본적으로 빌드 시점에 정적으로 페이지를 만든다는 것입니다.
- 페이지에서 외부 AP를 호출하거나 데이터베이스에 접근하는 등 동적 작업을 해야 한다면 해당하 는 함수를 페이지에 export해야 합니다.

<br>


## 2주차 정리 (23.09.07)
## 가. 프로젝트 생성 및 실행 방법

- create-next-app 이용하여  프로젝트 생성

```bash
npx create-next-app 프로젝트 파일명
```

- 프로젝트가 생성되면 프로젝트 디렉토리로 이동하여 다음 명령을 실행

```bash
npm run dev
```
<br>

## 나. Next.js 타입스크립트 지원

- Next.js는 타입스크립트로 작성되었기 때문에 고품질의 type definition을 지원합니다.
- 기본 언어를 타입스크립트로 지정하려면 root에 tsconfig.json이라는 설정파일 생성하면 됩니다.
- 패키지를 설치하고 나면 비어 있던 tsconfig.json 파일의 내용이 자동으로 채워집니다.
- 개발환경을 vscode 사용하면 설정 내용이 자동으로 채워지기 때문에 별도의 설치는 필요하지 않습니다.

```bash
npm install --save-dev tpyescipt @types/react @types/node
```
<br>

## 다. 바벨과 웹팩 설정 커스터마이징

- 바벨이나 웹팩의 설정도 커스터마이징 할 수 있습니다.
- 바벨은 자바스크립트 트랜스컴파일러이며, 최신 자바스크립트 코드를 하위 호환성을 보장 하는 스크립트 코드로 변환하는 일을 담당합니다.
- 하위 호환성이 보장되면 어떤 웹 브라우저에서든 자바스크립트 코드를 실행할 수 있습니다.
- 현재는 리엑트에서 바벨을 지원하지 않고 있습니다.

## 라. 웹팩

- 웹팩은 특정 라이브러리, 페이지, 기능에 대해 컴파일된 코드를 전부 포함하는 번들을 만들 어 줍니다.
- 라이브러리와 여러 개의 컴포트로 구성된 페이지를 개발했다면, 웹팩은 이 것을 하나의 번들로 합쳐줍니다.
- 만일 SASSL LESS 같은 CsS전처리기를 사용해서 개발하고 싶다면, 웹팩 설정을 수정해 주 면 됩니다. (설정 방법은 취급하지 않습니다.)

## 마. SWC를 포함한 프로젝트 생성

### SWC란?

- 말 그대로 **매우 빠른 자바스크립트 컴파일러**이며, 기존 Babel 이 하던 일의 대체제라고 합니다. 또한 SWC 는 컴파일러이지만 웹팩과 같은 자바스크립트 번들러의 기능도 제공하고 있다고 합니다. 따라서 그냥 컴파일러가 아닌 SWC 란 Rust 기반의 플랫폼입니다.

```bash
npx create-next-app@latest 파일명
```
<br>

## 1주차 정리 (23.08.31)

## 가.  Next.js

### **Next.js는 리액트를 위해 만든 오픈소스 자바스크립트 웹 프레임워크 입니다.**

1. 리액트는 페이스북의 조던 발케가 만들어, 2013년 오픈소스 발표
2. 리액트는 클라이언트 사이들에서만 작동한다는 문제점이 있습니다.
    - 애플리케이션 실행 초기에 성능 부담
    - 검색 엔진 최적화의 효과를 거의 볼 수 없음
3. 이 문제를 해결하기 위해 서버에서 미리 렌더링해 두는 방법을 연구
4. 이러한 연구의 결과로 나온 것이 Next.js

### **리액트에는 없는 다양한 기능을 제공합니다.**

1. 코드 분할 : 페이지를 로딩 할 때 번들을 여러 조각으로 나누어 필요한 부분만 전송하는 방식
2. 서버 사이트 렌더링
3. 파일 기반 라우팅
4. 경로 기반 프리페칭 : 사용자가 다음에 이동할 수 있는 페이지를 미리 가져오는 기술
5. 정적 사이트 생성
6. 증분 정적 콘텐츠 생성
7. 타입스크립트에 대한 기본 지원
8. 자동 폴리필 적용 : 이전 브라우저에서 최신 기능을 제공하는 데 필요한 코드를 제공
9. 이미지 최적화  : 컴포넌트로 제공하는 이미지의 최적화 시술
10. 웹 애플리케이션의 국제화 지원 : 다국어 지원
11. 성능 분석

## 나. SSR, SSG, ISR
<br>
1. 서버 사이트 렌더링(SSR: Server-side Rendering)

SSR은 서버에서 사용자에게 보여줄 페이지를 모두 미리 구성하여 사용자에게 페이지를 보여주는 방식이다. JSP/Servlet의 아키텍처에서 이 방식을 사용했다.

<img src="https://velog.velcdn.com/post-images%2Fjeff0720%2F55e9d780-10a8-11ea-8d2b-e372e2115d30%2FSSR.png">

출처 : [https://velog.io/@jeff0720/Next.js-개념-이해-부터-실습까지-해보는-SSR-환경-구축](https://velog.io/@jeff0720/Next.js-%EA%B0%9C%EB%85%90-%EC%9D%B4%ED%95%B4-%EB%B6%80%ED%84%B0-%EC%8B%A4%EC%8A%B5%EA%B9%8C%EC%A7%80-%ED%95%B4%EB%B3%B4%EB%8A%94-SSR-%ED%99%98%EA%B2%BD-%EA%B5%AC%EC%B6%95)

SSR을 사용하면 모든 데이터가 매핑된 서비스 페이지를 클라이언트(브라우저)에게 바로 보여줄 수 있다. 서버를 이용해서 페이지를 구성하기 때문에 클라이언트에서 구성하는 `CSR`(client-side rendering)보다 페이지를 구성하는 속도는 늦어지지만 전체적으로 사용자에게 보여주는 콘텐츠 구성이 완료되는 시점은 빨라진다는 장점이 있다. 더불어 SEO(search engine optimization) 또한 쉽게 구성할 수 있다.

<aside>
📍 CSR은 client side rendering 약자로 자바스크립트 파일을 브라우저에서 해석해 랜더링하는 방식**입니다.

</aside>
<br>
2. 정적 사이트 생성(SSG: static site Generation)

개발자가 빌드 시 사전생성페이지(pre-render page)를 만들어 static 페이지로 가지고 있게 됩니다. 클라이언트에서 페이지 요청 시 사전생성페이지를 로드하여 보여 줍니다. 페이지를 사전 생성하여 가지고 있기 때문에 클라이언트 요청에 대한 응답이 빠릅니다. 빌드 할 때 페이지가 생성되므로 변경사항이 생기게 되었을 때는 next.js의 특정 함수를 활용하여 변경사항을 읽은 다음 페이지를 생성 합니다.

<br>
3. 증분 정적 재생성(ISR: Incremental static Regeneration)

ISR은 일정 주기마다 데이터의 최신 여보를 검사해서 업데이트된 데이터로 다시 페이지를 생성한다.

콘텐츠가 업데이트되었을 때 업데이트 된 정보를 보여줄 없다는  SSG의 단점을 보완하기 위한 생성 방식이다.

 즉, NextJS에서 성능상의 이점은 챙기면서도 변화된 내용에 대한 업데이트를 제공해줄 수 있는 방식이 바로 `ISR`(Incremental Static Regeneration) 방식이다. 

정적생성으로 미리 만들어놓은 사이트들도 필요하다면 업데이트가 가능하다는 이야기이다. 이를 이용한다면 정적생성의 장점을 취하되 단점을 보완할 수 있게 되는 것이다. ISR은 기존의 정적생성 방식에 몇가지 옵션들을 추가하면 바로 적용이 가능하다.

<aside>
📍 SSG(정적 페이지 생성)는 미리 만들어 놓은 페이지들 서비스 하기 때문에 속도는 빠르지만, 한번 생성하고 나면 수정이 불가능합니다. 이러한 단점을 보완하고자 나온 것이 ISR(증분 정적 재생성)입니다.

</aside>

## 다. Next.js와 비슷한 프레임워크

### 1. Gatsby

- 정적 웹 사이트를 만들 수 있는 프레임워크 입니다.
- 정적 사이트 생성만 지원합니다.
- 클라이언트 사이드 렌더링 만 지원합니다.
- 동적으로 변하는 복잡한 웹 사이트는 만들 수 없습니

### 2. Razzle

- 서버 사이드 랜더링이 가능한 자바스크립트 애플리케이션 개발이 가능합니다.
- CRA와 유사하게 프로젝트를 구성할 수 있다는 장정이 있습니다. (create-razzle-
app)
- React , Preact , Reason-React, Angular 및 Vue 와 함께 사용할 수 있습니

### 3. Nuxt.js

- Vue들 사용한 웹 애플리케이션 개발에서 리액트의 Next.js에 해당하는 프레임워크 입니다.
- Nuxt.js나 Next.js 모두 같은 목표를 갖는 프레임워크지만 Nuxt js는 더 많은 설정이 필요합니다.

### s4. Angular Universal

- 정적 사이트 생성과 서버 사이드 렌터링을 지원합니다.
- Nuxt나 Next와는 달리 대기업인 구글에서 만들었습니다.
- Angular로 개발하는 경우 Angutar Universal을 사용하는 것이 대부분입니다.